---
title: "ST_Import_Preprocessing"
output: html_document
date: "2024-06-20"
---

Importing all of the spatial samples 
Preprocessing 
https://satijalab.org/seurat/articles/spatial_vignette#integration-with-single-cell-data 
https://satijalab.org/seurat/articles/visiumhd_analysis_vignette#install-seurat-update (updated version)

# Load library and objects
```{r load library}
library(Seurat)
library(SeuratData)
library(ggplot2)
library(patchwork)
library(dplyr)
library(hdf5r)
library(tidyr)
library(ggplot2)
#library(arrow)
```

```{r load objects}
output_dir = "/omics/groups/OE0436/internal/Linh/Output/ST/All_samples"
seurat_transformed = readRDS("/omics/groups/OE0436/internal/Linh/Datasets/Spatial_transcriptomics/Seurat_obj/seurat_transformed")

myRCTD_list = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/myRCTD_list") #RCTD object (individually,no DEA yet) 
TLS_maturity_score = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/TLS_maturity_score.rds")
myRCTD_DEA = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/myRCTD_DEA") #RCTD object (individually) 
filtered_genes_list = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/filtered_genes_list") #DEA results all samples (individually, threshold = 0)
#saveRDS(TLS_score,"/omics/groups/OE0436/internal/Linh/Output/ST/TLS_signature_score.rds")
#saveRDS(TLS_score,"/omics/groups/OE0436/internal/Linh/Output/ST/TLS_maturity_score.rds")
saveRDS(merge_ST,"/omics/groups/OE0436/internal/Linh/Output/ST/merge_ST") 
GeneCard_MP = read.csv("/omics/groups/OE0436/internal/Linh/Output/ST/GeneCards-SearchResults.csv")
# Extract first 1000 genes (With the highest relevant score)
GeneCard_MP = GeneCard_MP[1:1000,]
# Extact the gene names
GeneCard_MP = GeneCard_MP$Gene.Symbol
```
# - note Preprocessing metrics
24 samples. 16 TLS+ and 6 TLS- (TLS-: 48)
ended up only taking 22 samples bc 2 of the samples have different number of pixels in the object and the TLS annotation (GSM5924043 + GSM5924044)
Filtering: Spatial spots featuring more than 30% of mitochondrial genes and less than 300 genes were filtered out + Using SCT: automatically filter out the genes with counts in less than 5 spatial spots (https://github.com/satijalab/seurat/issues/6303) 

# Importing samples

```{r Importing samples}

#################### Importing samples 
data_dir = "/omics/groups/OE0436/data/Linh/Datasets/Spatial_transcriptomics/GSE175540/"
sample_names = paste0("GSM59240",30:53) #create vector that contain my sample names 
# Initialize an empty list to store the Seurat objects
seurat_objects <- list()
# Loop through each sample name and load the data
for (sample_name in sample_names) {
  sample_dir <- file.path(data_dir, sample_name)
  seurat_objects[[sample_name]] <- Load10X_Spatial(data.dir = sample_dir, assay = "Spatial")
}

```

```{r TLS annotation}

TLS_list <- list()

####################### importing TLS_annotation and put them in a list 
for (sample_name in sample_names) {
    tls_file <- file.path(data_dir, sample_name, "spatial","TLS_annotation.csv")
    
    if (file.exists(tls_file)) {
        TLS_list[[sample_name]] <- read.csv(tls_file, header=TRUE, stringsAsFactors=FALSE)
    } else {
        message(paste("Skipping", sample_name, "as TLS_annotation.csv file does not exist"))
    }
} #Skipping GSM5924034 as TLS_annotation.csv file does not exist


# Add the TLS annotation data to the corresponding Seurat object
for (sample_name in names(TLS_list)) {
    seurat_objects[[sample_name]]$TLS_anno <- TLS_list[[sample_name]]$TLS_2_cat
}

####################### Checking if the barcode from TLS annotation and the one in seurat object are identical (also in order)
for (sample_name in names(TLS_list)) {
  print(identical(TLS_list[[sample_name]]$Barcode, Cells(seurat_objects[[sample_name]]), attrib.as.set = FALSE)) #TRUE. Check if the barcodes in TLS annotation and the barcode in seurat are identical (order is also check)
} # All TRUE except 43 and 44: FALSE. Number of pixels in Seurat obj and in TLS list not the same 


# 43 and 44 excluding 
seurat_objects [["GSM5924043"]] = NULL
seurat_objects [["GSM5924044"]] = NULL
TLS_list [["GSM5924043"]] = NULL
TLS_list [["GSM5924044"]] = NULL


#-> Check if barcodes is identical now -> all TRUE


```

# Preprocessing

```{r nCount_Spatial}

# Initialize an empty list to store plots
plot_list <- list()

# Loop through each sample in seurat_objects and create plots
for (sample_name in names(seurat_objects)) {
    # Create the violin plot
    vln.plot <- VlnPlot(seurat_objects[[sample_name]], features = "nCount_Spatial", pt.size = 0) + 
        theme(axis.text = element_text(size = 4)) + 
        NoLegend() +  ggtitle(paste("Violin Plot -", sample_name))
  
    # Create the spatial feature plot
    count.plot <- SpatialFeaturePlot(seurat_objects[[sample_name]], features = "nCount_Spatial") + 
        theme(legend.position = "right") + ggtitle(paste("Violin Plot -", sample_name))
    
    # Combine the plots
    combined_plot <- vln.plot | count.plot
    
    # Add the combined plot to the list
    plot_list[[sample_name]] <- combined_plot
}
all_combined_plots <- wrap_plots(plot_list)

# Combine all plots into a single plot using patchwork
pdf(paste0(output_dir,"/Preprocessing/nCount.pdf"), width = 2500, height = 2000)
all_combined_plots
dev.off()


```


```{r Filtering}

subset_seurat <- function(seurat_obj) {
  subset(seurat_obj, subset = nFeature_Spatial > 300 & percent.mt < 30)
}

seurat_objects <- lapply(seurat_objects, subset_seurat)
#pbmc <- subset(pbmc, subset = nFeature_RNA > 300 & percent.mt < 30) #Spatial spots featuring more than 30% of mitochondrial genes and less than 300 genes were filtered out
```

```{r QC metrics}

for (sample_name in names(seurat_objects)) {
  seurat_objects[[sample_name]][["percent.mt"]] <- PercentageFeatureSet(seurat_objects[[sample_name]], pattern = "^MT-")
}

# Visualize QC metrics as a violin plot
plot_list <- list()


# Use lapply instead of a for loop
plot_list <- lapply(names(seurat_objects), function(sample_name) {
  # Create the violin plot
  vln.plot <- VlnPlot(seurat_objects[[sample_name]], features = "nCount_Spatial") + 
    theme(legend.position = "right") + 
     NoLegend() + # adding no legend 
    ggtitle(paste0(sample_name,"\n","nCount")) 
  
  # Create the spatial feature plot
  count.plot <- VlnPlot(seurat_objects[[sample_name]], features = "nFeature_Spatial") + 
    theme(legend.position = "right") + 
     NoLegend() + 
    ggtitle(paste0("\n","nFeature"))
  
  mt.plot <- VlnPlot(seurat_objects[[sample_name]], features = "percent.mt") + 
    theme(legend.position = "right") + 
    ggtitle(paste0("\n","percent.mt"))
  
  
  # Combine the plots
   combined_plot <- (vln.plot | count.plot | mt.plot) + 
    plot_annotation(title = sample_name)
  
  
  # Return the combined plot
  return(combined_plot)
})

# Combine all the plots into one
names(plot_list) <- names(seurat_objects)
all_combined_plots <- wrap_plots(plot_list)


png(paste0(output_dir,"/Preprocessing/QC_metric.png"), width = 2500, height = 2000)
all_combined_plots
dev.off()

```

```{r TLS Annotation Visulization}

# plotting only TLS positive samples

TLS_neg = c("GSM5924048","GSM5924042","GSM5924045","GSM5924047","GSM5924034","GSM5924036")
# Subset seurat_objects to exclude those in TLS_neg
seurat_pos <- seurat_objects[setdiff(names(seurat_objects), TLS_neg)] #16 obj

#### sample GSM5924032: TLS annotation contains "" (no inf?) 
sum(seurat_pos[["GSM5924032"]]@meta.data[["TLS_anno"]] ==  "")
#[1] 23 : pixels contain no info about TLS 
pixels = seurat_transformed[["GSM5924032"]]@meta.data[["TLS_anno"]] ==  "" #which pixels have annotation ""
seurat_transformed[["GSM5924032"]]@meta.data[["TLS_anno"]] [pixels] = "NO_TLS"
#### same for 49: 
#### sample GSM5924049: TLS annotation contains "" (no inf?) 
sum(seurat_transformed[["GSM5924049"]]@meta.data[["TLS_anno"]] ==  "") #1108
#[1] 23 : pixels contain no info about TLS 
pixels = seurat_transformed[["GSM5924049"]]@meta.data[["TLS_anno"]] ==  "" #which pixels have annotation ""
seurat_transformed[["GSM5924049"]]@meta.data[["TLS_anno"]] [pixels] = "NO_TLS"
####

# Function to create SpatialPlot for a Seurat object with customized group.by
create_spatial_plot <- function(seurat_obj, sample_name) {
  DefaultAssay(seurat_obj) <- "Spatial"
  if ("TLS_anno" %in% colnames(seurat_obj@meta.data)) {
    plot <- SpatialPlot(seurat_obj, group.by = "TLS_anno") + 
            ggtitle(paste0(sample_name, "\nTLS Annotation"))
  } else {
    plot <- ggplot() + 
            ggtitle(paste0(sample_name, "\nTLS Annotation not available"))
  }
  return(plot)
}

# Apply the function to each Seurat object in the list with the corresponding sample name
plots <- lapply(seurat_pos, function(sample_name) {
  create_spatial_plot(seurat_pos[[sample_name]], sample_name)
})

combined_plot <- wrap_plots(plots)
png(paste0(output_dir,"/Preprocessing/TLS_Annotation.png"), width = 2500, height = 2000)
combined_plot
dev.off()

# Plot only 46
png("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/Preprocessing/TLS_Annotation_46.png", width = 800, height = 800)
SpatialPlot(seurat_transformed[["GSM5924046"]], group.by = "TLS_anno") + 
            ggtitle( "TLS Annotation")
dev.off()

### some samples looks a bit different, its bc some of them have less pixels, half of them FFPE, half frozen 
```
```{r Cell and Feature count}
cell_counts <- sapply(seurat_transformed, function(x) length(Cells(x))) #afterQC
cell_counts_b4QC <- sapply(seurat_objects, function(x) length(Cells(x)))

genes_counts <- sapply(seurat_transformed, function(x) length(Features(x))) #afterQC
genes_counts_b4QC <- sapply(seurat_objects, function(x) length(Features(x)))

sum(cell_counts) #53416
sum(cell_counts_b4QC) #74220
53416/74220 #0.7196982
```


# Normalisation

```{r}

transform_seurat <- function(seurat_obj) {
  SCTransform(seurat_obj, assay = "Spatial", verbose = FALSE)
}

seurat_transformed <- lapply(seurat_pos, transform_seurat)

```

# Clustering

```{r}

transform_seurat <- function(seurat_obj) {
  seurat_obj = RunPCA(seurat_obj, assay = "SCT", verqbose = FALSE)
  seurat_obj = FindNeighbors(seurat_obj, reduction = "pca", dims = 1:40)
  seurat_obj = FindClusters(seurat_obj, verbose = FALSE,resolution = 0.3)
  seurat_obj = RunUMAP(seurat_obj, reduction = "pca", dims = 1:40)
}

seurat_transformed <- lapply(seurat_transformed, transform_seurat)

# Visualization


# Use lapply instead of a for loop
plot_list <- lapply(names(seurat_transformed), function(sample_name) {
      
    p1 <- DimPlot(seurat_transformed[[sample_name]], reduction = "umap", label = TRUE) + ggtitle (sample_name)
    p2 <- SpatialDimPlot(seurat_transformed[[sample_name]], label = TRUE, label.size = 3)
  
  # Combine the plots
   combined_plot <- (p1 | p2) +  plot_annotation(title = sample_name)
  
  # Return the combined plot
  return(combined_plot)
})

# Combine all the plots into one
all_combined_plots <- wrap_plots(plot_list)

png(paste0(output_dir,"/Preprocessing/Clusters.png"), width = 2500, height = 2000)
all_combined_plots
dev.off()

```



```{r klappt noch nicht - highlighting TLS regions}

add_polygons_around_tls <- function(seurat_object, group.by = "TLS_anno", shape = "polygon") {
  # Extract spatial coordinates and annotations
  coords <- as.data.frame(seurat_object@images$slice1@coordinates)
  annotations <- seurat_object@meta.data[, group.by]
  
  # Combine coordinates and annotations into a single data frame
  coord_anno_df <- cbind(coords, annotations = annotations)
  
  # List of unique annotations (TLS regions)
  unique_annotations <- unique(coord_anno_df$annotations)
  
  # Create a base SpatialDimPlot
  spatial_plot <- SpatialDimPlot(seurat_object,label = TRUE, label.size = 3)
  
  # Loop through each unique annotation and add shapes around the regions
  for (anno in unique_annotations) {
    region_coords <- coord_anno_df %>% filter(annotations == anno)
    
    if (shape == "polygon") {
      hull_coords <- region_coords %>% slice(chull(imagerow, imagecol))
      spatial_plot <- spatial_plot + 
        geom_polygon(data = hull_coords, aes(x = imagerow, y = imagecol), 
                     fill = NA, color = "black", size = 1)
    } else if (shape == "circle") {
      # Calculate centroid for each region
      centroid <- region_coords %>% summarise(Simagerow = mean(imagerow), imagecol = mean(imagecol))
      radius <- max(dist(region_coords[, c("imagerow", "imagecol")]))
      spatial_plot <- spatial_plot + 
        annotate("path",
                 x = centroid$imagerow + radius * cos(seq(0, 2 * pi, length.out = 100)),
                 y = centroid$imagecol + radius * sin(seq(0, 2 * pi, length.out = 100)),
                 color = "black", size = 1)
    }
  }
  
  return(spatial_plot)
}

# Example usage with a Seurat object
polygon_plot <- add_polygons_around_tls(seurat_transformed[[1]], shape = "polygon")
circle_plot <- add_polygons_around_tls(seurat_transformed[[1]], shape = "circle")

print(polygon_plot)
print(circle_plot)


p = SpatialDimPlot(seurat_transformed[[1]])

# Extract the coordinates of TLS cells
tls_obj = seurat_transformed[[1]]@meta.data[["TLS_anno"]] == "TLS" # extracting the seurat obj that have are TLS positive
tls_coords <- GetTissueCoordinates(seurat_transformed[[1]])
tls_coords = tls_coords [tls_obj,]



# Convert coordinates to a data frame
tls_coords_df <- as.data.frame(tls_coords)
colnames(tls_coords_df) <- c("spatial_1", "spatial_2")
#rownames(tls_coords_df) = tls_cells
# Add borders to highlight TLS regions
p + geom_point(data = as.data.frame(tls_coords_df), 
               aes(x = spatial_1, y = spatial_2), 
               color = "red", size = 1, shape = 21, stroke = 2, fill = NA) 

Idents(seurat_transformed[[1]]) = 
p + SpatialPlot(seurat_transformed[[1]], group.by = "TLS_anno") 
seurat_transformed[[1]] <- StashIdent(object = seurat_transformed[[1]], save.name = "old.ident")
# next try 

tls = Cells(seurat_transformed[["GSM5924030"]] [, seurat_transformed[["GSM5924030"]]@meta.data[["TLS_anno"]] == "TLS"])

tls_coords = GetTissueCoordinates(seurat_transformed[["GSM5924030"]])
tls_coords = tls_coords[rownames(tls_coords) %in% tls,]

tls_coords_df <- as.data.frame(tls_coords)

p + geom_point(data = as.data.frame(tls_coords), 
               aes(x = imagerow, y = imagecol), 
               color = "black", size = 0.2, shape = 21, stroke = 2, fill = NA) 

p + SpatialPlot(seurat_transformed[["GSM5924030"]], group.by = "TLS_anno")


### next try



# Example Seurat object
seurat_obj <- seurat_transformed[["GSM5924030"]]  # Replace with your Seurat object

# Identify barcodes to highlight (example: TLS positive cells)
barcodes_to_highlight <- Cells (seurat_obj@meta.data$TLS_anno == "TLS")

# Create a subset of data based on identified barcodes
highlight_data <- seurat_obj@meta.data[seurat_obj@meta.data$barcode %in% barcodes_to_highlight, ]

# Generate the base plot (replace with appropriate function: SpatialDimPlot, SpatialFeaturePlot, etc.)
p <- SpatialDimPlot(seurat_obj, label = TRUE, label.size = 3)

# Plot with geom_point to highlight specific barcodes
p + geom_point(data = highlight_data, 
               aes(x = imagecol, y = imagerow), 
               color = "red", size = 3, shape = 21, fill = NA, stroke = 2)

# next try
Idents(seurat_transformed[[1]]) = c(seurat_transformed[["GSM5924030"]]@meta.data[["seurat_clusters"]],seurat_transformed[["GSM5924030"]]@meta.data[["TLS_anno"]])

SpatialDimPlot(seurat_transformed[["GSM5924030"]])

seurat_transformed[[1]] = StashIdent(seurat_transformed[[1]],seurat_transformed[["GSM5924030"]]@meta.data[["TLS_anno"]])

```

# Spatial Feature plot
```{r}

# Use lapply instead of a for loop
plot_list <- lapply(names(seurat_transformed), function(sample_name) {
  if ("PDCD1" %in% Features(seurat_transformed[[sample_name]])) {
    plot <- SpatialFeaturePlot(seurat_transformed[[sample_name]], features = c("PDCD1")) + ggtitle (sample_name)
  } else {
    plot <- ggplot() + 
            ggtitle(paste0(sample_name, "\nPDCD1 not available"))
  }

})

# Combine all the plots into one
all_combined_plots <- wrap_plots(plot_list)

png(paste0("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/SpatialFeaturePlot/PDCD1.png"), width = 2500, height = 2000)
all_combined_plots
dev.off()

genes = c("MRC1", "CD163", "TGM2", "STAT6","FCGR3A", "CYBB", "TLR2", "STAT1")
png(paste0("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/SpatialFeaturePlot/M1M2_Boxplot.png"), width = 1500, height = 1000)
SpatialFeaturePlot(seurat_transformed[["GSM5924046"]], features = genes,ncol = 4) 
dev.off()


#TGM2 (M2a) MSR1 (Pattern recognition scavenger receptor CD204). CD209 (weniger pixels). CSF1R. VSIG4
# M2: CLEC7A? MERTK? STAT1
```
```{r Rhama genes}
genes_vector <- c("AKNA", "LTB", "TRBC1", "SASH3", "JAK3", "PLAC8", "CXCL13", "ARHGAP45", "PLCB2", "DOCK2", "STK4", 
                  "SP140", "GPR174", "CD48", "ITGA4", "FCMR", "SPIB", "GRAPL", "LCP1", "IKZF1", "CD28", "PYHIN1", 
                  "CNTRL", "PTPRCAP", "CBX7", "BIRC3", "RBL2", "INPP5D", "PATL2", "PTPRC", "ARHGAP9", "TOX", "CD53", 
                  "EVI2B", "RAC2", "CD5", "CD37", "BANK1", "KLF2", "RESF1", "CARD8", "RASAL3", "MYO1F", "ITGAL", 
                  "SLC19A2", "ERBB3", "PRKCB", "NFATC2", "TLR1")

# Loop through each gene in genes_vector
for (gene in genes_vector) {
  plot_list <- lapply(names(seurat_transformed), function(sample_name) {
    if (gene %in% Features(seurat_transformed[[sample_name]])) {
      plot <- SpatialFeaturePlot(seurat_transformed[[sample_name]], features = c(gene)) + ggtitle(sample_name)
    } else {
      plot <- ggplot() + 
              ggtitle(paste0(sample_name, "\n", gene, " not available"))
    }
  })
  
  # Combine all the plots into one
  all_combined_plots <- wrap_plots(plot_list)
  
  # Save the combined plots as an image
  output_file <- paste0("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/SpatialFeaturePlot/", gene, ".png")
  png(output_file, width = 2500, height = 2000)
  print(all_combined_plots)
  dev.off()
}
```

# Boxplot


```{r}

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(reshape2)  # for melt function

```

```{r try to plot multiple samples together}

gene = "FCGR3A" #cd163

plots_list <- list()
for (sample_id in names(seurat_transformed)) {
  sample <- seurat_transformed[[sample_id]]
  
  # Subset to TLS positive and TLS negative regions
  pos_reg <- subset(sample, subset = TLS_anno == "TLS")
  neg_reg <- subset(sample, subset = TLS_anno == "NO_TLS")
  
  # Get the SCT normalized data for the gene of interest
  pos_reg_norm <- as.matrix(pos_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
  neg_reg_norm <- as.matrix(neg_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
  
  # Perform Welch's 2-sample t-test
  ttest <- t.test(pos_reg_norm, neg_reg_norm, paired = FALSE)
  p_value <- ttest$p.value
  
  # Prepare data for plotting
  pos <- data.frame(Expression = as.numeric(pos_reg_norm), Condition = "TLS_positive_region")
  neg <- data.frame(Expression = as.numeric(neg_reg_norm), Condition = "TLS_negative_region")
  combined <- rbind(pos, neg)
  
  # Plot with ggplot
  p <- ggplot(combined, aes(x = Condition, y = Expression, fill = Condition)) +
    geom_boxplot(alpha = 0.5, outlier.size = 2, width = 0.5) +
    labs(title = paste(sample_id), y = "Expression") +
    scale_fill_manual(values = c("TLS_positive_region" = "#1b9e77", "TLS_negative_region" = "#d95f02")) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      axis.title = element_text(size = 14),
      legend.title = element_blank(),
      legend.position = "top"
    ) +
    annotate("text", x = 1.5, y = max(combined$Expression),
             label = ifelse(p_value < 0.001, "p < 0.001 (***)",
                            ifelse(p_value < 0.01, "p < 0.005 (**)",
                                   ifelse(p_value < 0.05, "p < 0.05 (*)", ""))),
             hjust = 0.5, vjust = -0.5, size = 4, color = "black") +
    geom_text(aes(x = 1.5, y = max(combined$Expression), 
                  label = ifelse(p_value < 0.0005, "***",
                                 ifelse(p_value < 0.005, "**",
                                        ifelse(p_value < 0.05, "*", "")))),
              size = 6, hjust = 0.5, vjust = -0.5, color = "white", inherit.aes = FALSE)
  
  # Store plot in list
  plots_list[[sample_id]] <- p
}

# Arrange plots for display
multiplot <- wrap_plots (plots_list,ncol =4)

# Print or save the combined plot
png ("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/Boxplots/FCGR3A.png",width = 1500, height = 1700)
multiplot
dev.off()

```

```{r plot 46}
library(patchwork)
FCGR3A = SpatialFeaturePlot(seurat_transformed[["GSM5924046"]], features = c("FCGR3A"))
CD163 = SpatialFeaturePlot(seurat_transformed[["GSM5924046"]], features = c("CD163")) 
TLR2 = SpatialFeaturePlot(seurat_transformed[["GSM5924046"]], features = c("TLR2")) 
MRC1 = SpatialFeaturePlot(seurat_transformed[["GSM5924046"]], features = c("MRC1")) 

plot_list = list(CD163,MRC1,FCGR3A,TLR2)
combine_plot = wrap_plots(plot_list) +  plot_annotation ("M1 and M2 markers in GSM5924046")
```
# Integration
```{r}

# Find integration anchors
merge_ST <- merge(x = seurat_transformed[[1]], y = c( seurat_transformed[[2]],
                  seurat_transformed[[3]], seurat_transformed[[4]],
                  seurat_transformed[[5]], seurat_transformed[[6]],
                  seurat_transformed[[7]], seurat_transformed[[8]],
                  seurat_transformed[[9]], seurat_transformed[[10]],
                  seurat_transformed[[11]], seurat_transformed[[12]],
                  seurat_transformed[[13]], seurat_transformed[[14]],
                  seurat_transformed[[15]], seurat_transformed[[16]])) 

# run standard anaysis workflow
merge_ST <- NormalizeData(merge_ST)
DefaultAssay(merge_ST) = "Spatial"
merge_ST = DietSeurat(merge_ST, assays = "Spatial")
merge_ST <- FindVariableFeatures(merge_ST)
merge_ST <- ScaleData(merge_ST)
merge_ST <- RunPCA(merge_ST)

DimPlot(merge_ST, reduction = "umap")

merge_ST <- IntegrateLayers(object = merge_ST, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca",
    verbose = FALSE)


# Integrate the datasets
integrated <- IntegrateData(anchorset = anchors, normalization.method = "SCT")

```

# Boxplot neg vs pos

```{r}

pos_combine <- matrix(nrow = 1, ncol = 0)
neg_combine = matrix(nrow = 1, ncol = 0)
for (sample_id in names(seurat_transformed)) {

  sample <- seurat_transformed[[sample_id]]
  
  # Subset to TLS positive and TLS negative regions
  pos_reg <- subset(sample, subset = TLS_anno == "TLS")
  neg_reg <- subset(sample, subset = TLS_anno == "NO_TLS")
  
  # Get the SCT normalized data for the gene of interest
  pos_reg_norm <- as.matrix(pos_reg@assays[["SCT"]]@data["CYBB", , drop = FALSE])
  neg_reg_norm <- as.matrix(neg_reg@assays[["SCT"]]@data["CYBB", , drop = FALSE])

  pos_combine = cbind (pos_combine,pos_reg_norm)
  neg_combine = cbind (neg_combine,neg_reg_norm)
}
  # Perform Welch's 2-sample t-test
  ttest <-   wilcox.test(pos_combine, neg_combine, paired = FALSE)
  p_value <- ttest$p.value
  p_value #CD163: sig. CD68: sig (0.002). TLR2 = 0.2474. FCGR3A = 0.04. MRC1 = 2.665706e-21. CD86:  8.42882e-09. CD80:  6.507553e-08
```

```{r}
# Define your genes of interest
genes <- c("MRC1", "CD163", "TGM2", "MSR1", "VSIG4", "CSF1R", "STAT6","FCGR3A", "CYBB", "TLR2", "CD40", "CD86", "STAT1")
genes_new <- c("MRC1", "CD163", "TGM2", "STAT6","FCGR3A", "CYBB", "TLR2", "STAT1")

# Initialize lists to store combined data
pos_combine <- list()
neg_combine <- list()

# Initialize empty matrices for each gene
for (gene in genes_new) {
  pos_combine[[gene]] <- matrix(nrow = 1, ncol = 0)
  neg_combine[[gene]] <- matrix(nrow = 1, ncol = 0)
}

# Iterate over each sample
for (sample_id in names(seurat_transformed)) {
  sample <- seurat_transformed[[sample_id]]
  
  # Subset to TLS positive regions
  pos_reg <- subset(sample, subset = TLS_anno == "TLS")
  neg_reg <- subset(sample, subset = TLS_anno == "NO_TLS")


  # Get the SCT normalized data for each gene and combine them
  for (gene in genes_new) {
    pos_gene <- as.matrix(pos_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
    neg_gene <- as.matrix(neg_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
    pos_combine[[gene]] <- cbind(pos_combine[[gene]], pos_gene)
    neg_combine[[gene]] <- cbind(neg_combine[[gene]], neg_gene)
  }
}

# Initialize a dataframe to store results
results_df <- data.frame(
  gene = character(),
  p_value = numeric()
)

plots_list = list()
# Perform paired t-tests for each pair of M2 and M1 genes
for (gene in genes_new) {
  
    # Perform paired t-test
    ttest <- wilcox.test(pos_combine[[gene]], neg_combine[[gene]], paired = F)
    p_value <- ttest$p.value
    
    # Store results in the dataframe
    results_df <- rbind(results_df, data.frame(gene = gene, p_value = p_value))
    # Prepare data for plotting
    pos_data <- data.frame(Expression = as.vector(pos_combine[[gene]]), Condition = "TLS positive regions")
    neg_data <- data.frame(Expression = as.vector(neg_combine[[gene]]), Condition = "TLS negative regions")
    combined <- rbind(pos_data, neg_data)
    
    # Plot with ggplot
    p <- ggplot(combined, aes(x = Condition, y = Expression, fill = Condition)) +
      geom_boxplot(alpha = 0.5, outlier.size = 2, width = 0.5) +
      stat_summary(fun.y=mean, geom="point", shape=20, size=5, color="red", fill="red") +
      labs(title = paste(gene," expression"), y = "Expression") +
      scale_fill_manual(values = c( "TLS positive regions" = "#1b9e77", "TLS negative regions"= "#d95f02")) +
      theme_minimal(base_size = 14) +
      theme(
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 14),
        legend.title = element_blank(),
        legend.position = "top"
      ) +
      annotate("text", x = 1.5, y = max(combined$Expression),
               label = ifelse(p_value < 0.001, "p < 0.001 (***)",
                              ifelse(p_value < 0.01, "p < 0.005 (**)",
                                     ifelse(p_value < 0.05, "p < 0.05 (*)", ""))),
               hjust = 0.5, vjust = -0.5, size = 4, color = "black") +
      geom_text(aes(x = 1.5, y = max(combined$Expression), 
                    label = ifelse(p_value < 0.0005, "***",
                                   ifelse(p_value < 0.005, "**",
                                          ifelse(p_value < 0.05, "*", "")))),
                size = 6, hjust = 0.5, vjust = -0.5, color = "white", inherit.aes = FALSE)
     
    # Store plot in list
    plots_list[[gene]] <- p
  
}
# Arrange plots for display
multiplot <- wrap_plots (plots_list,ncol =4)

# Print or save the combined plot
png ("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/Boxplots/PosvsNeg_final4.png",width = 1300, height = 1000)
multiplot
dev.off()


```

problem is that: if I compare gene expression of gene A outside and inside TLS -> is higher, maybe it does not mean that MP express the marker more in TLS, but that there are more MP in TLS?
-> Instead, compare the expression of M1 to M2 in TLS?? 
Does it than make sense to do the DEA of TLS and non TLS pixels? (C-SIDE: comparing gene expression of TLS pixels and non TLS pixels -> up and downregulated genes -> filter for MP genes -> Maybe do 25%??)

To the thesis:  For instance, the identification of tumor associated macrophages (TAMs), which do not fit nicely into the criteria for M1 or M2 macrophages complicates this system

# Boxplot M2 vs M1

```{r}

# M2 markers
MRC1_combine <- matrix(nrow = 1, ncol = 0)
CD163_combine = matrix(nrow = 1, ncol = 0)
TGM2_combine <- matrix(nrow = 1, ncol = 0)
MSR1_combine = matrix(nrow = 1, ncol = 0)
VSIG4_combine <- matrix(nrow = 1, ncol = 0)
CSF1R_combine = matrix(nrow = 1, ncol = 0)
STAT6_combine =  matrix(nrow = 1, ncol = 0)
# M1 markers
FCGR3A_combine <- matrix(nrow = 1, ncol = 0) 
CYBB_combine = matrix(nrow = 1, ncol = 0)
TLR2_combine =  matrix(nrow = 1, ncol = 0)
CD40_combine =  matrix(nrow = 1, ncol = 0)
CD86_combine =  matrix(nrow = 1, ncol = 0)
STAT1_combine =  matrix(nrow = 1, ncol = 0)

# CLEC7A? MERTK?: too less pixels (50 51)
#TGM2 (M2a) MSR1 (Pattern recognition scavenger receptor CD204). CD209 (weniger pixels). CSF1R. VSIG4
for (sample_id in names(seurat_transformed)) {

 sample <- seurat_transformed[[sample_id]]
  
  # Subset to TLS positive and TLS negative regions
  pos_reg <- subset(sample, subset = TLS_anno == "TLS")
  
  # Get the SCT normalized data for the gene of interest
  # M2 markers
  MRC1 <- as.matrix(pos_reg@assays[["SCT"]]@data["MRC1", , drop = FALSE])
  CD163 = as.matrix(pos_reg@assays[["SCT"]]@data["CD163", , drop = FALSE])
  TGM2 = as.matrix(pos_reg@assays[["SCT"]]@data["TGM2", , drop = FALSE])
  MSR1 = as.matrix(pos_reg@assays[["SCT"]]@data["MSR1", , drop = FALSE])
  VSIG4 = as.matrix(pos_reg@assays[["SCT"]]@data["VSIG4", , drop = FALSE])
  CSF1R = as.matrix(pos_reg@assays[["SCT"]]@data["CSF1R", , drop = FALSE])
  STAT6 = as.matrix(pos_reg@assays[["SCT"]]@data["STAT6", , drop = FALSE])

  # M1 markers
  FCGR3A <- as.matrix(pos_reg@assays[["SCT"]]@data["FCGR3A", , drop = FALSE])
  CYBB <- as.matrix(pos_reg@assays[["SCT"]]@data["CYBB", , drop = FALSE])
  TLR2 <- as.matrix(pos_reg@assays[["SCT"]]@data["TLR2", , drop = FALSE])
  CD40 <- as.matrix(pos_reg@assays[["SCT"]]@data["CD40", , drop = FALSE])
  CD86 <- as.matrix(pos_reg@assays[["SCT"]]@data["CD86", , drop = FALSE])
  STAT1 <- as.matrix(pos_reg@assays[["SCT"]]@data["STAT1", , drop = FALSE])

  FCGR3A_combine = cbind (FCGR3A_combine,FCGR3A)
  CD163_combine = cbind (CD163_combine,CD163)
  MRC1_combine = cbind (MRC1_combine,MRC1)
  CYBB_combine = cbind (CYBB_combine,CYBB)
  
  # M2 markers
  MRC1_combine <- cbind (MRC1_combine,MRC1)
  CD163_combine =cbind (CD163_combine,CD163)
  TGM2_combine <- cbind (TGM2_combine,TGM2)
  MSR1_combine = cbind (MSR1_combine,MSR1)
  VSIG4_combine <- cbind (VSIG4_combine,VSIG4)
  CSF1R_combine = cbind (CSF1R_combine,CSF1R)
  STAT6_combine =  cbind (STAT6_combine,STAT6)
  # M1 markers
  FCGR3A_combine <- cbind (FCGR3A_combine,FCGR3A)
  CYBB_combine = cbind (CYBB_combine,CYBB)
  TLR2_combine = cbind (TLR2_combine,TLR2)
  CD40_combine =  cbind (CD40_combine,CD40)
  CD86_combine =  cbind (CD86_combine,CD86)
  STAT1_combine =  cbind (STAT1_combine,STAT1)
}



  # Perform paired student t test
  ttest <-   t.test(MRC1_combine, FCGR3A_combine, paired = T, alternative = "less")
  p_value <- ttest$p.value
  p_value
  # FCGR3A_combine less than CD163_combine  2.121529e-76
   # FCGR3A_combine greater than MRC1_combine  6.048396e-132
   # CYBB_combine greater than MRC1_combine 1.891025e-146
  # CYBB_combine less than CD163_combine  4.208813e-55
  # At the same time: can you say that MP phenotype is express M2 expression bc CD163 (M2 marker) is greater than M1 marker? CD1163 expression is just higher, esp bc it is in tumor microenvironment. 
  
  
```
=> Plan: 
1. M1 and M2 inside TLS zu vergleichen: -> some M1 > M2 and some M2 > M1 
-> TLS-MP does not show a distinct M1 or M2 phenotype (or: TLS-MP shows a mixed M1 and M2 phenotype!!!)
-> Plot: Boxplot (4 M1 and 4 M2 markers) 
2. M1 in TLS vergleichen mit M1 (auch CYBB) outside TLS and same with M2 
3. Plot:+ 1 sample: all markers 

Than: vergleichen 
tlhl2132!

```{r}
# Load necessary libraries
library(ggplot2)

# Define your genes of interest
M2_genes <- c("MRC1", "CD163", "TGM2", "MSR1", "VSIG4", "CSF1R", "STAT6")
M1_genes <- c("FCGR3A", "CYBB", "TLR2", "CD40", "CD86", "STAT1")


M2_genes <- c("MRC1", "CD163", "TGM2","STAT6") #new
M1_genes <- c("FCGR3A", "CYBB", "TLR2","STAT1") #new

# Initialize lists to store combined data
M2_combine <- list()
M1_combine <- list()

# Initialize empty matrices for each gene
for (gene in c(M2_genes, M1_genes)) {
  M2_combine[[gene]] <- matrix(nrow = 1, ncol = 0)
  M1_combine[[gene]] <- matrix(nrow = 1, ncol = 0)
}

# Iterate over each sample
for (sample_id in names(seurat_transformed)) {
  sample <- seurat_transformed[[sample_id]]
  
  # Subset to TLS positive regions
  pos_reg <- subset(sample, subset = TLS_anno == "TLS")
  
  # Get the SCT normalized data for each gene and combine them
  for (gene in M2_genes) {
    gene_data <- as.matrix(pos_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
    M2_combine[[gene]] <- cbind(M2_combine[[gene]], gene_data) # list of M2 genes in 2220 TLS pos spatial spots 
  }
  for (gene in M1_genes) {
    gene_data <- as.matrix(pos_reg@assays[["SCT"]]@data[gene, , drop = FALSE])
    M1_combine[[gene]] <- cbind(M1_combine[[gene]], gene_data) # list
  }
}

# Initialize a dataframe to store results
results_df <- data.frame(
  M2_gene = character(),
  M1_gene = character(),
  p_value = numeric()
)

plots_list = list()
# Perform paired t-tests for each pair of M2 and M1 genes
for (M2_gene in M2_genes) {
  for (M1_gene in M1_genes) {
    # Perform paired t-test
    ttest <- t.test(M2_combine[[M2_gene]], M1_combine[[M1_gene]], paired = TRUE, alternative = "two.sided")
    p_value <- ttest$p.value
    
    # Store results in the dataframe
    results_df <- rbind(results_df, data.frame(M2_gene = M2_gene, M1_gene = M1_gene, p_value = p_value))
    # Prepare data for plotting
    M2_data <- data.frame(Expression = as.vector(M2_combine[[M2_gene]]), Condition = "M2 marker", Gene = M2_gene)
    M1_data <- data.frame(Expression = as.vector(M1_combine[[M1_gene]]), Condition = "M1 marker", Gene = M1_gene)
    combined <- rbind(M2_data, M1_data)
    
    # Plot with ggplot
    p <- ggplot(combined, aes(x = Condition, y = Expression, fill = Condition)) +
      geom_boxplot(alpha = 0.5, outlier.size = 2, width = 0.5) +
      stat_summary(fun.y=mean, geom="point", shape=20, size=5, color="red", fill="red") +
      labs(title = paste(M2_gene, "vs", M1_gene), y = "Expression") +
      scale_fill_manual(values = c("M2 marker" = "#58508d",  "M1 marker" = "#d4b200")) +
      theme_minimal(base_size = 14) +  
      theme(
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 14),
        legend.title = element_blank(),
        legend.position = "top"
      ) +
      annotate("text", x = 1.5, y = max(combined$Expression),
               label = ifelse(p_value < 0.001, "p < 0.001 (***)",
                              ifelse(p_value < 0.01, "p < 0.005 (**)",
                                     ifelse(p_value < 0.05, "p < 0.05 (*)", ""))),
               hjust = 0.5, vjust = -0.5, size = 4, color = "black") +
      geom_text(aes(x = 1.5, y = max(combined$Expression), 
                    label = ifelse(p_value < 0.0005, "***",
                                   ifelse(p_value < 0.005, "**",
                                          ifelse(p_value < 0.05, "*", "")))),
                size = 6, hjust = 0.5, vjust = -0.5, color = "white", inherit.aes = FALSE)
    
    # Store plot in list
    plots_list[[paste(M2_gene, "vs", M1_gene)]] <- p
  }
}
# Arrange plots for display
multiplot <- wrap_plots (plots_list,ncol =4)

# Print or save the combined plot
png ("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/Boxplots/M1vsM2_final4.png",width = 1000, height = 1500)
multiplot
dev.off()

```

# Dotplot
```{r Dotplots}
results_df <- data.frame(M2_gene = character(), M1_gene = character(), p_value = numeric(), M2_higher = logical(), stringsAsFactors = FALSE)

# Perform paired t-tests and store the results
for (M2_gene in M2_genes) {
  for (M1_gene in M1_genes) {
    # Perform paired t-test
    ttest <- t.test(M2_combine[[M2_gene]], M1_combine[[M1_gene]], paired = TRUE, alternative = "two.sided")
    p_value <- ttest$p.value
    M2_higher <- mean(M2_combine[[M2_gene]]) > mean(M1_combine[[M1_gene]])
    
    # Store results in the dataframe
    results_df <- rbind(results_df, data.frame(M2_gene = M2_gene, M1_gene = M1_gene, p_value = p_value, M2_higher = M2_higher))
  }
}


# Convert p-values to -log10(p-value)
results_df$log_p_value <- -log10(results_df$p_value)

ggplot(results_df, aes(x = M1_gene, y = M2_gene)) +
  geom_point(aes(size = log_p_value, color = M2_higher)) +
  scale_color_manual(values = c("red", "blue"), labels = c("M1 higher", "M2 higher")) +
  scale_size(range = c(1, 10)) +
  labs(title = "Comparison of M1 and M2 marker expression levels in TLS positive spatial spots", x = "M1 markers", y = "M2 markers", color = "", size = "-log10(p-value)") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1))

```


# TLS Classification
After looking at the IGHG1 and CXCL13, a few of the them are non sig higher in TLS, or even lower 
APOE: some of them are lower in TLSW (as expected), but some are higher in TLS -> maturity?


```{r Import core signatures}
tls_core_signature <- c("CCL2","CCL3","CCL4","CCL5","CCL8","CCL18","CCL19","CCL21","CXCL9","CXCL10","CXCL11","CXCL12", "CXCL13","CD79B", 
"CETP","LAT", "CD1D", "PTGDS","CXCR5","SELL","ICOS","SH2D1A","TIGIT","PDCD1",                 
"BANK1","CD22","CD79A","CR1","FCRL2", "MS4A1", "FCER2", "LAMP3","CD86","CD80","CD83","CCR7") # 36 genes

maturity_markers <-  c("CR2", "BCL6", "MKI67", "MADCAM1", "CCL19", "CCL21", "CXCL13", "MZB1", "SDC1", "CD38", "CD19","MS4A1", "CD27","IGHG1", "IGHA1", "CD79A", "FCER2", "CD4", "CD274", "ICOS","CXCR5", "IFNG") #22 genes?

```


```{r subset for TLS regions}

###### subset for TLS regions
seurat_TLS <- lapply(seurat_transformed, function(x) subset(x, subset = TLS_anno == "TLS"))

###### take the normalised data
seurat_TLS = lapply(seurat_TLS, function(x) x@assays[["SCT"]]@data)

###### subset for tls_core_sig
# Define a function to subset the data based on tls_core_signature, handling missing genes
subset_genes <- function(seurat_obj, gene_list) {
  # Find the intersection of gene_list and the rownames of the Seurat object data
  genes_to_keep <- intersect(gene_list, rownames(seurat_obj))
  # Subset the Seurat object data based on the genes_to_keep
  seurat_obj[genes_to_keep, ]
}

# Apply the function to each element in the seurat_TLS list
seurat_TLS <- lapply(seurat_TLS, subset_genes, gene_list = tls_core_signature) 
# TLS_core_signatures: from 32 to 36 genes 
# maturity markers: 16 to 22 genes
```

```{r calculating the mean}
          
seurat_TLS = lapply(seurat_TLS, function(x) rowMeans(x))

# geometric mean
#
library(psych)
geo_mean = seurat_TLS
geo_mean = lapply (geo_mean, function(x) x*1000)#to handle 0 values
geo_mean = lapply (geo_mean, function(x) x+1)#to handle 0 values

geo_mean_df <- lapply(geo_mean, function(x) geometric.mean(x)) #2: columns # a lot of 0 initially 

TLS_score = as.data.frame(geo_mean_df) 
TLS_score
#saveRDS(TLS_score,"/omics/groups/OE0436/internal/Linh/Output/ST/TLS_signature_score.rds")
#saveRDS(TLS_score,"/omics/groups/OE0436/internal/Linh/Output/ST/TLS_maturity_score.rds")

TLS_sig = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/TLS_signature_score.rds")
# sum(17.8762,  28.13698, 26.22897 ,27.27601 ,22.39938,  18.00745 , 20.48693 , 18.71535,   29.15955 )/ 9  for TLS high group
#[1] 23.14298
# all larger than 18 


# sum(8.963966 +  9.383337+  8.012426 + 17.88228  )/ 4 for TLS med group
#[1] 11.0605
# all larger than 8

# (sum(8.963966 + 3.896696 + 4.612294 + 3.120081))/4 for TLS low  group
#[1] 3.876357

```

# Correlation analysis

Correlation between maturity score and expression of APOE/PDCD1 in TLS (the expression inside TLS/expression outside TLS)

```{r Preparing input}

##### subset for TLS regions
seurat_TLS <- lapply(seurat_transformed, function(x) subset(x, subset = TLS_anno == "TLS"))
seurat_nonTLS <- lapply(seurat_transformed, function(x) subset(x, subset = TLS_anno == "NO_TLS"))

###### take the normalised data
seurat_TLS = lapply(seurat_TLS, function(x) x@assays[["SCT"]]@data)
seurat_nonTLS <- lapply(seurat_nonTLS, function(x) x@assays[["SCT"]]@data)

###### subset for certain genes

# Apply the function to each element in the seurat_TLS list
gene = "MZB1"
gene_TLS <- lapply(seurat_TLS, function(x) x[gene,]) 
gene_TLS <- lapply(seurat_TLS, function(x) mean(x)) 
gene_nonTLS <- lapply(seurat_nonTLS, function(x) x[gene,]) 
gene_nonTLS <- lapply(seurat_nonTLS, function(x) mean(x)) 

for (i in 1:length(seurat_TLS)){
  gene_TLS[[i]] = seurat_TLS [[i]] ["SPP1",]
  gene_TLS[[i]] = mean(gene_TLS[[i]])
}
### FOXP3
gene_TLS <- lapply(seurat_TLS, function(x) {
  if ("FOXP3" %in% rownames(x)) {
    return(x["FOXP3",])
  } else {
    return(NULL)
  }
})

gene_TLS <- Filter(Negate(is.null), gene_TLS)


for (i in 1:length(seurat_nonTLS)){
  gene_nonTLS[[i]] = seurat_nonTLS [[i]] ["SPP1",]
  gene_nonTLS[[i]] = mean(gene_nonTLS[[i]])
}



```

```{r Preparing cell types proportion input}

########################### function like plotting cell proportion bar plots, aside for taking top10 -> take all 
########### TLS regions
prop_barplot = function(seu_obj,norm_weights){
  # Identify TLS-positive regions
  TLS_region = seu_obj@meta.data[["TLS_anno"]] == "TLS" # the cluster relate to TLS positive
  TLS_region = Cells(seu_obj[,TLS_region]) #extract the barcode of the pixel for TLS positve pixel
  TLS_region = norm_weights@Dimnames[[1]] %in% TLS_region # which pixels is TLS positive in the norm_weight 
  TLS = as.data.frame(norm_weights) [TLS_region,] #extract the pixel in normweight that are TLS positive 
  
  # Calculate the mean weight for each cell type across all pixels
  mean_weight <- as.data.frame(colMeans(TLS))
  mean_weight <- cbind(rownames(mean_weight), mean_weight)
  colnames(mean_weight) <- c("CellType", "Weights")
  
  return (mean_weight)
}

# Apply the function to each Seurat object and its corresponding norm_weights
mean_weight = mapply(prop_barplot, seurat_transformed, norm_weights, SIMPLIFY = FALSE) #mapply is used to apply RunRCTD to each pair of myRCTD_list and explanatory_variable_list. SIMPLIFY = FALSE ensures the output is a list.

# taking Treg
Treg_prop = lapply(mean_weight,function(x) x["Treg",])
Treg_prop = sapply(Treg_prop,function(x) x[["Weights"]])
# taking CD4
CD4_prop = lapply(mean_weight,function(x) x["CD4",])
CD4_prop = sapply(CD4_prop,function(x) x[["Weights"]])
########################### function like plotting cell proportion bar plots, aside for taking top10 -> take all 
########### TLS negative regions (do the same, except for norm_weights [-TLS_region,])

prop_barplot = function(seu_obj,norm_weights){
  # Identify TLS-positive regions
  TLS_region = seu_obj@meta.data[["TLS_anno"]] == "TLS" # the cluster relate to TLS positive
  TLS_region = Cells(seu_obj[,TLS_region]) #extract the barcode of the pixel for TLS positve pixel
  TLS_region = norm_weights@Dimnames[[1]] %in% TLS_region # which pixels is TLS positive in the norm_weight 
  TLS = as.data.frame(norm_weights) [-TLS_region,] #extract the pixel in normweight that are TLS positive 
  
  # Calculate the mean weight for each cell type across all pixels
  mean_weight <- as.data.frame(colMeans(TLS))
  mean_weight <- cbind(rownames(mean_weight), mean_weight)
  colnames(mean_weight) <- c("CellType", "Weights")
  
  return (mean_weight)
}

# Apply the function to each Seurat object and its corresponding norm_weights
mean_weight = mapply(prop_barplot, seurat_transformed, norm_weights,SIMPLIFY = FALSE) #mapply is used to apply RunRCTD to each pair of myRCTD_list and explanatory_variable_list. SIMPLIFY = FALSE ensures the output is a list.

# taking Treg

Treg_prop_neg = lapply(mean_weight,function(x) x["Treg",])
Treg_prop_neg = sapply(Treg_prop_neg,function(x) x[["Weights"]])
```

```{r Correlation analysis}
APOE = as.numeric(gene_TLS)/as.numeric(gene_nonTLS)
SPP1 = as.numeric(gene_TLS)/as.numeric(gene_nonTLS)
# Eliminate 
#MZB1 = as.numeric(gene_TLS)/as.numeric(gene_nonTLS)

#APOE
# [1] 0.9001858 0.7542218 0.9899423 1.1108506 1.1627272 0.4931089 1.0400925 1.0914331 0.9340636 1.5349724 1.0622092 1.2159931
#[13] 0.9399427 1.6190933 0.9890281 1.1886681
#APOE: normalised data, TLSreg/TLS_nonreg
# [1] 0.9592486 0.8613404 0.9090676 1.0562968 0.8799786 0.9959639 1.0242333 0.9026301 1.0434149 1.0465937 0.9560437 0.9213720 0.8348883 1.1128861
#[15] 0.8864498 1.0020354
SPP1 = as.numeric(gene_TLS)/as.numeric(gene_nonTLS)

MZB1 = as.numeric(gene_TLS)

FOXP3 =  as.numeric(gene_TLS)
TLS_signature_score = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/TLS_signature_score.rds")

cor.test(as.numeric(APOE),as.numeric(Treg_prop/Treg_prop_neg), method = "pearson") # pvalue = 0.3 
#SPP1 and maturity: p = 0.11
#SPP1 and TLS core sig: p = 0.06 
#APOE and maturity: p = 0.3818
#PDCD1 some how correlated with maturity score (non sig)
```


```{r Correlation analysis with selected samples}


# remove 35,39,50,51,52,53
to_rm = c("GSM5924035","GSM5924039","GSM5924050","GSM5924051","GSM5924052","GSM5924053")
to_rm_index = names(TLS_maturity_score) %in% to_rm
TLS_maturity_score = TLS_maturity_score[to_rm_index == F]

Treg_prop = Treg_prop[to_rm_index == F]

APOE = as.numeric(gene_TLS)/as.numeric(gene_nonTLS)

names(SPP1) = names()
cor.test(as.numeric(Treg_prop),as.numeric(TLS_maturity_score), method = "pearson") # pvalue = 0.3 

```

# RCTD 
## RCTD (individually): to ST_RCTD_allsamples_cluster.R

```{r normalisation results}

myRCTD_list = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/myRCTD_list")
results_list <- lapply(myRCTD_list, function(x) x@results)
# normalize the cell type proportions to sum to 1.
norm_weights = lapply(results_list, function(x) normalize_weights(x$weights))

```

## RCTD (combine 2): 
Combine all submit to clusters

```{r offset coord}

# Offset for slice 2 (adjust the offset values as needed)
slide1 = seurat_transformed[[1]]
slide2 = seurat_transformed[[2]]
slide3 = seurat_transformed[[3]]
slide4 = seurat_transformed[[4]]
slide5 = seurat_transformed[[5]]
slide6 = seurat_transformed[[6]]
slide7 = seurat_transformed[[7]]
slide8 = seurat_transformed[[8]]
slide9 = seurat_transformed[[9]]
slide10 = seurat_transformed[[10]]
slide11 = seurat_transformed[[11]]
slide12 = seurat_transformed[[12]]
slide13 = seurat_transformed[[13]]
slide14 = seurat_transformed[[14]]
slide15 = seurat_transformed[[15]]
slide16 = seurat_transformed[[16]]

slide2@images[["slice1"]]@coordinates[["imagerow"]] <- slide2@images[["slice1"]]@coordinates[["imagerow"]] + max(slide1@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide2@images[["slice1"]]@coordinates[["imagecol"]] <- slide2@images[["slice1"]]@coordinates[["imagecol"]] + max(slide1@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide3@images[["slice1"]]@coordinates[["imagerow"]] <- slide3@images[["slice1"]]@coordinates[["imagerow"]] + max(slide2@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide3@images[["slice1"]]@coordinates[["imagecol"]] <- slide3@images[["slice1"]]@coordinates[["imagecol"]] + max(slide2@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide4@images[["slice1"]]@coordinates[["imagerow"]] <- slide4@images[["slice1"]]@coordinates[["imagerow"]] + max(slide3@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide4@images[["slice1"]]@coordinates[["imagecol"]] <- slide4@images[["slice1"]]@coordinates[["imagecol"]] + max(slide3@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide5@images[["slice1"]]@coordinates[["imagerow"]] <- slide5@images[["slice1"]]@coordinates[["imagerow"]] + max(slide4@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide5@images[["slice1"]]@coordinates[["imagecol"]] <- slide5@images[["slice1"]]@coordinates[["imagecol"]] + max(slide4@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide6@images[["slice1"]]@coordinates[["imagerow"]] <- slide6@images[["slice1"]]@coordinates[["imagerow"]] + max(slide5@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide6@images[["slice1"]]@coordinates[["imagecol"]] <- slide6@images[["slice1"]]@coordinates[["imagecol"]] + max(slide5@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide7@images[["slice1"]]@coordinates[["imagerow"]] <- slide7@images[["slice1"]]@coordinates[["imagerow"]] + max(slide6@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide7@images[["slice1"]]@coordinates[["imagecol"]] <- slide7@images[["slice1"]]@coordinates[["imagecol"]] + max(slide6@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide8@images[["slice1"]]@coordinates[["imagerow"]] <- slide8@images[["slice1"]]@coordinates[["imagerow"]] + max(slide7@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide8@images[["slice1"]]@coordinates[["imagecol"]] <- slide8@images[["slice1"]]@coordinates[["imagecol"]] + max(slide7@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide9@images[["slice1"]]@coordinates[["imagerow"]] <- slide9@images[["slice1"]]@coordinates[["imagerow"]] + max(slide8@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide9@images[["slice1"]]@coordinates[["imagecol"]] <- slide9@images[["slice1"]]@coordinates[["imagecol"]] + max(slide8@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide10@images[["slice1"]]@coordinates[["imagerow"]] <- slide10@images[["slice1"]]@coordinates[["imagerow"]] + max(slide9@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide10@images[["slice1"]]@coordinates[["imagecol"]] <- slide10@images[["slice1"]]@coordinates[["imagecol"]] + max(slide9@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide11@images[["slice1"]]@coordinates[["imagerow"]] <- slide11@images[["slice1"]]@coordinates[["imagerow"]] + max(slide10@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide11@images[["slice1"]]@coordinates[["imagecol"]] <- slide11@images[["slice1"]]@coordinates[["imagecol"]] + max(slide10@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry

slide12@images[["slice1"]]@coordinates[["imagerow"]] <- slide12@images[["slice1"]]@coordinates[["imagerow"]] + max(slide11@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide12@images[["slice1"]]@coordinates[["imagecol"]] <- slide12@images[["slice1"]]@coordinates[["imagecol"]] + max(slide11@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry


slide13@images[["slice1"]]@coordinates[["imagerow"]] <- slide13@images[["slice1"]]@coordinates[["imagerow"]] + max(slide12@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide13@images[["slice1"]]@coordinates[["imagecol"]] <- slide13@images[["slice1"]]@coordinates[["imagecol"]] + max(slide12@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry


slide14@images[["slice1"]]@coordinates[["imagerow"]] <- slide14@images[["slice1"]]@coordinates[["imagerow"]] + max(slide13@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide14@images[["slice1"]]@coordinates[["imagecol"]] <- slide14@images[["slice1"]]@coordinates[["imagecol"]] + max(slide13@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry


slide15@images[["slice1"]]@coordinates[["imagerow"]] <- slide15@images[["slice1"]]@coordinates[["imagerow"]] + max(slide14@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide15@images[["slice1"]]@coordinates[["imagecol"]] <- slide15@images[["slice1"]]@coordinates[["imagecol"]] + max(slide14@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry


slide16@images[["slice1"]]@coordinates[["imagerow"]] <- slide16@images[["slice1"]]@coordinates[["imagerow"]] + max(slide15@images[["slice1"]]@coordinates[["imagerow"]]) + 100 #slide2@images[["slice1"]] is correct no worry
slide16@images[["slice1"]]@coordinates[["imagecol"]] <- slide16@images[["slice1"]]@coordinates[["imagecol"]] + max(slide15@images[["slice1"]]@coordinates[["imagecol"]]) + 100 #slide2@images[["slice1"]] is correct no worry


merge_slice = merge(slide1,c(slide2,slide3,slide4,slide5,slide6,slide7,slide8,slide9,slide10,slide11,slide12,slide13,slide14,slide15,slide16))
#merge_slice = JoinLayers(merge_slice)
# TRy RCTD on these 2 samples

  
```


```{r RCTD}
########### sc ref
ref = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/sc_ref") #SCT, with annotation, joined layers (ccRCC)
random_cells = sample(Cells(ref),15000)
ref_sub = ref[,random_cells]


counts = ref_sub@assays[["SCT"]]@counts
counts@Dimnames[[1]] = Features(ref_sub)
counts@Dimnames[[2]] = Cells(ref_sub)
cell_types = ref_sub@meta.data[["celltype1"]]
#cell_types <- gsub("/", "_", cell_types)
#any(is.na(cell_types))
#na_cells <- which(is.na(cell_types)) 
#counts <- counts[, -na_cells]
#cell_types <- cell_types[-na_cells]

names(cell_types) = counts@Dimnames[[2]]
#nUMI = ref_sub@meta.data[["nCount_RNA"]] 
#names(nUMI) = colnames(ref_sub)

### Create the Reference object
reference <- Reference(counts, as.factor(cell_types), colSums(counts)) 

#######
# coord of the first samples 
imagerow = c(merge_slice@images[["slice1"]]@coordinates[["imagerow"]],merge_slice@images[["slice1.2"]]@coordinates[["imagerow"]])
imagecol = c(merge_slice@images[["slice1"]]@coordinates[["imagecol"]],merge_slice@images[["slice1.2"]]@coordinates[["imagecol"]])
coords = data.frame (imagerow, imagecol)
colnames(coords) <- c("x", "y")
rownames(coords) = Cells(merge_slice)
# Remove columns with NA in column names
coords <- coords[, !is.na(colnames(coords))]
counts <- merge_slice[["SCT"]]$counts 

query <- SpatialRNA(coords, counts, colSums(counts)) # it wokred!!!! 

myRCTD <- create.RCTD(query, reference, max_cores = 8)
myRCTD <- run.RCTD(myRCTD, doublet_mode = 'full')

```

```{r normalisation results}
results <- myRCTD_list@results
# normalize the cell type proportions to sum to 1.
norm_weights = normalize_weights(results$weights) 
cell_type_names <- myRCTD@cell_type_info$info[[2]] #list of cell type names

```


# C-SIDE
## C-SIDE (individually): ST_C_SIDE_cluster.R

```{r Determining regions for DEA}

CSIDE_input = function (seu_obj) {
  # Identifying TLS positive regions (output: logical vector)
  TLS = seu_obj$TLS_anno == "TLS"
  # preparing the explanatory variable (#The explanatory variable itself is a vector of values, constrained between 0 and 1, with names matching the pixel names of the myRCTD object.)
  pixel_names <- Cells(seu_obj)
  explanatory_variable <- rep(0, length(pixel_names))
  explanatory_variable[pixel_names %in% rownames(GetTissueCoordinates(seu_obj)[TLS, ])] <- 1  # Assign 1 to TLS positive regions
  names(explanatory_variable) <- pixel_names
  return(explanatory_variable)
}

input <- lapply(seurat_transformed, CSIDE_input) #apply the function onto seurat object lists 

```




```{r}
RunRCTD = function(myRCTD) {
  myRCTD@config$max_cores <- 2
  myRCTD <- run.CSIDE.single(myRCTD, explanatory_variable, cell_types = "Macro",  doublet_mode = F, weight_threshold = 0, cell_type_threshold = 0) 
}

myRCTD_list = lappy (myRCTD_list, RunRCTD)

# Explaining the threshold: 0.25 -> In TLS regions: accumulation of a lot of B and T cells. If set weight threshold higher -> not enough pixels to use
#-> Solution: I have multiple samples -> maybe combine it 

```

```{r}

myRCTD_list_DEA = myRCTD_list_DEA_new[-which(sapply(myRCTD_list_DEA_new, is.null))]

# Extract all genes and add gene names as a column for each list element
all_genes <- lapply(myRCTD_list_DEA_new, function(x) {
  gene_data <- x@de_results[["all_gene_list"]][["Macro"]]
  gene_data$gene_name <- rownames(gene_data)
  return(gene_data)
})

#MP_gene and MP_gene2 taken from ST_Deconvolution_1sample.Rmd

# Function to filter and merge genes for a single data frame
filter_and_merge_genes <- function(gene_data, MP_gene_database) {
  filtered_all <- gene_data[gene_data$gene_name %in% MP_gene_database, ]
  return(filtered_all)
}

filtered_genes_list <- lapply(all_genes, filter_and_merge_genes, GeneCard_MP)
saveRDS(filtered_genes_list,"/omics/groups/OE0436/internal/Linh/Output/ST/filtered_genes_list") #DEA results all samples (individually, threshold = 0)
filtered_genes_list = readRDS ("/omics/groups/OE0436/internal/Linh/Output/ST/filtered_genes_list")
```

```{r}
# Define the function to filter and label differential expression
label_diffexpressed <- function(df) {
  df$diffexpressed <- "NO"
  df$diffexpressed[df$log_fc > 0.4 & df$p_val < 0.05] <- "UP"
  df$diffexpressed[df$log_fc < -0.4 & df$p_val < 0.05] <- "DOWN"
  return(df)
}

# Apply the function to each data frame in the list
up_down_list <- lapply(filtered_genes_list, label_diffexpressed)

extract_up_down <- function(df) {
 # df<- df[!duplicated(df$gene_name), ]
  up_reg <- df$diffexpressed == "UP"
  down_reg <- df$diffexpressed == "DOWN"
  gene_name_up = df$gene_name[up_reg]
  gene_name_down = df$gene_name[down_reg]
  return(list(gene_name_up = gene_name_up, gene_name_down = gene_name_down))
}

# Assuming filtered_genes_list is your list of data frames
up_down_list <- lapply(up_down_list,  extract_up_down)
#UP = unlist(sapply(up_down_list, function(x) x[["gene_name_up"]]))
######################
UP = lapply(up_down_list, function(x) x[["gene_name_up"]])
UP = unlist(UP)

# Count the frequency of each gene name
gene_counts <- table(UP)
# Convert to a data frame for easier viewing

gene_counts_df <- as.data.frame(gene_counts)
colnames(gene_counts_df) <- c("Gene", "Count")
####################
DOWN = lapply(up_down_list, function(x) x[["gene_name_down"]])
DOWN = unlist(DOWN)

# Count the frequency of each gene name
gene_counts_down <- table(DOWN)
# Convert to a data frame for easier viewing
gene_counts_df_down <- as.data.frame(gene_counts_down)
colnames(gene_counts_df_down) <- c("Gene", "Count")
```


##C-SIDE (combine)


```{r Dtermining TLS regions}

 # Identifying TLS positive regions (output: logical vector)
  TLS = merge_slice$TLS_anno == "TLS"
  # preparing the explanatory variable (#The explanatory variable itself is a vector of values, constrained between 0 and 1, with names matching the pixel names of the myRCTD object.)
  pixel_names <- Cells(merge_slice)
  explanatory_variable <- rep(0, length(pixel_names))
  explanatory_variable[pixel_names %in% rownames(coords)[TLS ]] <- 1  # Assign 1 to TLS positive regions
  names(explanatory_variable) <- pixel_names #384 pixels TLS positive
  
```

```{r Run CSIDE}
myRCTD@config$max_cores <- 2
myRCTD <- run.CSIDE.single(myRCTD, explanatory_variable, cell_types = "Macro",doublet_mode = F, weight_threshold = 0.5, cell_type_threshold = 60)  # 
# RUN ST_RCTD_CSIDE_combine2




```


```{r Filter for MP genes}

# Extract all genes and add gene names as a column for each list element
 gene_data <- myRCTD@de_results[["all_gene_list"]][["Macro"]]
 gene_data$gene_name <- rownames(gene_data)

# Function to filter and merge genes for a single data frame
filtered_all <- gene_data[gene_data$gene_name %in% GeneCard_MP, ]

  filtered_all$diffexpressed <- "NO"
  filtered_all$diffexpressed[filtered_all$log_fc > 0.4 & filtered_all$p_val < 0.005] <- "UP"
  filtered_all$diffexpressed[filtered_all$log_fc < -0.4 & filtered_all$p_val < 0.005] <- "DOWN"
```


## Extracting CSIDE  results
```{r Not filter for MP genes}
myRCTD = readRDS("/omics/groups/OE0436/internal/Linh/Output/ST/myRCTD_combine_DEA")

DEA_combine = myRCTD@de_results[["sig_gene_list"]][["Macro"]]
DEA_combine$gene_name = rownames(DEA_combine)

gene_data <- myRCTD@de_results[["all_gene_list"]][["Macro"]]
gene_data$gene_name = rownames(gene_data)

  
filtered_all$diffexpressed <- "NO"
filtered_all$diffexpressed[filtered_all$log_fc > 0.4 & filtered_all$p_val < 0.005] <- "UP"
filtered_all$diffexpressed[filtered_all$log_fc < -0.4 & filtered_all$p_val < 0.005] <- "DOWN"
```

# Cell proportion

### Cell proportion

INPUT: norm_weights: list of normalised proportion for each samples

```{r}

########################### Plot the proportion of cell types for TLS_positive

prop_barplot = function(seu_obj,norm_weights){
  # Identify TLS-positive regions
  TLS_region = seu_obj@meta.data[["TLS_anno"]] == "TLS" # the cluster relate to TLS positive
  TLS_region = Cells(seu_obj[,TLS_region]) #extract the barcode of the pixel for TLS positve pixel
  TLS_region = norm_weights@Dimnames[[1]] %in% TLS_region # which pixels is TLS positive in the norm_weight 
  TLS = as.data.frame(norm_weights) [TLS_region,] #extract the pixel in normweight that are TLS positive 
  
  # Calculate the mean weight for each cell type across all pixels
  mean_weight <- as.data.frame(colMeans(TLS))
  mean_weight <- cbind(rownames(mean_weight), mean_weight)
  colnames(mean_weight) <- c("CellType", "Weights")
  
  # Take the 10 cell types with the most weights
  top_10 <- mean_weight[order(-mean_weight$Weights), ][1:10, ]
  return (top_10)
}

# Apply the function to each Seurat object and its corresponding norm_weights
top10_list = mapply(prop_barplot, seurat_transformed,norm_weights, SIMPLIFY =  F) #mapply is used to apply RunRCTD to each pair of myRCTD_list and explanatory_variable_list. SIMPLIFY = FALSE ensures the output is a list.

# Generate the plot 

output_dir = "/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/RCTD/Barplots/"
for (i in 1:length(top10_list)){
  sample_name = names (norm_weights[[i]])
  plot_path <- paste0(output_dir,sample_name[[i]], ".png")
  
  png(plot_path, width = 500, height = 1000)
    ggplot(top10_list[[i]], aes(x = "", y = Weights, fill = CellType)) +
      geom_bar(stat = "identity") +
      theme_minimal() +
      labs(x = "CellType", y = "Weights", title = "Stacked Barplot of 10 Cell Types in TLS regions") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  dev.off()
}



####### for loop didnt work. next try
i = 16
sample_name = names(top10_list)
plot_path <- paste0(output_dir,sample_name[[i]], ".png")
png(plot_path, width = 500, height = 1000)
    ggplot(top10_list[[i]], aes(x = "", y = Weights, fill = CellType)) +
      geom_bar(stat = "identity") +
      theme_minimal() +
      labs(x = "CellType", y = "Weights", title = "Stacked Barplot of 10 Cell Types in TLS regions") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
dev.off()



########################### Plot the proportion of cell types for TLS_negative (exactly like above, but norm_weigh[-TLS_region,])

prop_barplot = function(seu_obj,norm_weights){
  # Identify TLS-positive regions
  TLS_region = seu_obj@meta.data[["TLS_anno"]] == "TLS" # the cluster relate to TLS positive
  TLS_region = Cells(seu_obj[,TLS_region]) #extract the barcode of the pixel for TLS positve pixel
  TLS_region = norm_weights@Dimnames[[1]] %in% TLS_region # which pixels is TLS positive in the norm_weight 
  TLS = as.data.frame(norm_weights) [-TLS_region,] #extract the pixel in normweight that are TLS positive 
  
  # Calculate the mean weight for each cell type across all pixels
  mean_weight <- as.data.frame(colMeans(TLS))
  mean_weight <- cbind(rownames(mean_weight), mean_weight)
  colnames(mean_weight) <- c("CellType", "Weights")
  
  # Take the 10 cell types with the most weights
  top_10 <- mean_weight[order(-mean_weight$Weights), ][1:10, ]
  return (top_10)
}

# Apply the function to each Seurat object and its corresponding norm_weights
top10_list_neg = mapply(prop_barplot, seurat_transformed,norm_weights, SIMPLIFY =  F) #mapply is used to apply RunRCTD to each pair of myRCTD_list and explanatory_variable_list. SIMPLIFY = FALSE ensures the output is a list.
sample_name = names(top10_list)

# Generate the plot 
i = 3
  plot_path <- paste0(output_dir,sample_name[[i]], ".png")
  png(plot_path, width = 500, height = 1000)
      ggplot(top10_list_neg[[i]], aes(x = "", y = Weights, fill = CellType)) +
        geom_bar(stat = "identity") +
        theme_minimal() +
        labs(x = "CellType", y = "Weights", title = "Stacked Barplot of 10 Cell Types in TLS regions") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  dev.off()
  
```

```{r Plot 1 barplot for all} 
prop_barplot = function(seu_obj,norm_weights){
  # Identify TLS-positive regions
  TLS_region = seu_obj@meta.data[["TLS_anno"]] == "TLS" # the cluster relate to TLS positive
  TLS_region = Cells(seu_obj[,-TLS_region]) #extract the barcode of the pixel for TLS positve pixel
  TLS_region = norm_weights@Dimnames[[1]] %in% TLS_region # which pixels is TLS positive in the norm_weight 
  TLS = as.data.frame(norm_weights) [TLS_region,] #extract the pixel in normweight that are TLS positive 
  
  # Calculate the mean weight for each cell type across all pixels
  mean_weight <- as.data.frame(colMeans(TLS))
  mean_weight <- cbind(rownames(mean_weight), mean_weight)
  colnames(mean_weight) <- c("CellType", "Weights")
  
  return (mean_weight)
}

# Apply the function to each Seurat object and its corresponding norm_weights
all_list = mapply(prop_barplot, seurat_transformed,norm_weights, SIMPLIFY =  F) #mapply is used to apply RunRCTD to each pair of myRCTD_list and explanatory_variable_list. SIMPLIFY = FALS

all_df = as.data.frame(all_list)
c = c(2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32)
all_df = all_df[,c ]
mean_df = as.data.frame(rowMeans(all_df))
colnames(mean_df) = "Weights"
mean_df$CellType = rownames(mean_df)
#top_10 <- as.data.frame(mean_df[order(-mean_df)][1:10])
 
  png("/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/RCTD/Barplots/Allsamples_Barplot/TLS_neg.png", width = 500, height = 1000)
      ggplot(mean_df, aes(x = "", y = Weights, fill = CellType)) +
        geom_bar(stat = "identity") +
        theme_minimal() +
        labs(x = "CellType", y = "Weights", title = "Stacked Barplot of cell types outside TLS regions") +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  dev.off()
  
  
  ##################
  
```


# Volcano 
```{r}

```


```{r}

png ("/omics/groups/OE0436/data/Linh/Output/ST/RCTD/ccRCC_ref/DEA/Volcano.png",width = 700, height = 1000)
ggplot(data = filtered_merge_all, aes(x = log_fc, y = -log10(p_val), col = diffexpressed, label = delabel)) +
  geom_vline(xintercept = c(-0.5,0.5), col = "gray", linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.0005), col = "gray", linetype = 'dashed') + 
  geom_point(size = 1) + 
  scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable  
                     labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
  coord_cartesian(ylim = c(0, 100), xlim = c(-2, 2)) + # since some genes can have minuslog10padj of inf, we set these limits
  labs(color = 'Severe', #legend_title, 
     x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) + 
  scale_x_continuous(breaks = seq(-2, 2, 0.5)) + # to customise the breaks in the x axis
  ggtitle('TLS positive vs TLS negative regions')  + geom_text_repel(max.overlaps = Inf) # To show all labels 
dev.off ()


```

```{r}

up_down_list <- lapply(filtered_genes_list, label_diffexpressed)

# Example operation to add labels based on conditions
update_labels <- function(df) {
  df$gene_symbol <- rownames(df)
  df$delabel <- ifelse(df$gene_symbol %in% head(df[(df$log_fc > 0.5 & df$p_val < 0.0005) | (df$log_fc < -0.5 & df$p_val < 0.0005), "gene_symbol"], 20), df$gene_symbol, NA)
  return(df)
}

up_down_list <- lapply(up_down_list, update_labels)

# Function to create plot and save as PNG
plot_and_save <- function(df, output_path) {
  # Create the plot
  p <- ggplot(data = df, aes(x = log_fc, y = -log10(p_val), col = diffexpressed, label = delabel)) +
    geom_vline(xintercept = c(-0.4, 0.4), col = "gray", linetype = 'dashed') +
    geom_hline(yintercept = -log10(0.005), col = "gray", linetype = 'dashed') + 
    geom_point(size = 1) + 
    scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"),
                       labels = c("Downregulated", "Not significant", "Upregulated")) +
    coord_cartesian(ylim = c(0, 20), xlim = c(-2, 2)) + # CHANGE y THRESHOLD DEPENDS ON DATA
    labs(color = 'Severity', x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) + 
    scale_x_continuous(breaks = seq(-2, 2, 0.5)) +
    ggtitle('TLS positive vs TLS negative regions') + 
    geom_text_repel(size = 2) #max.overlaps = Inf,
  
  # Save the plot as PNG
  ggsave(filename = output_path, plot = p)
}

output_dir = "/omics/groups/OE0436/internal/Linh/Output/ST/All_samples/RCTD/Volcano"
lapply(names(up_down_list), function(name) {
  plot_and_save(up_down_list[[name]], paste0(output_dir, "Volcano_", name, ".png"))
})

########## Plot only for 35
  plot_and_save(up_down_list[["GSM5924035"]], paste0(output_dir, "Volcano_", "GSM5924035", ".png"))


```

